from functools import wraps
from urllib.parse import quote

from flask import current_app, jsonify, redirect, url_for
from flask_login import current_user


# Designed to mimic JavaScript's encodeURIComponent(), from StackOverflow
def encode_URI_component(s: str) -> str:
    return quote(s, safe="~!*()'")


# GET requests to banned pages (meaning page has not been loaded yet) redirects to login with ABSOLUTE URL as `next` param
# (instead of relative generated by @login_required, to allow for cross-domain redirects)
# and POST requests on banned pages (meaning page is already loaded) shows login modal again via standard Ajax
# (instead of relying on CSRF token expiration and handleAjaxErrors() in JS to tell when session expires)
def custom_unauthorized(request):
    if not current_user.is_authenticated:
        if request.method == "GET":
            return redirect(url_for(current_app.config["LOGIN_VIEW"], next=encode_URI_component(request.url)))
        elif request.method == "POST":
            return jsonify(relogin=True)
    return None


# Same thing as custom_unauthorized() but use as a decorator
def custom_login_required(request):
    def inner_decorator(func):
        @wraps(func) # seems to allow double decorator to work if this is the second decorator (like what @login_required does)
        def wrapped(*args, **kwargs):
            result = custom_unauthorized(request)
            if result:
                return result
            return func(*args, **kwargs)
        return wrapped
    return inner_decorator

